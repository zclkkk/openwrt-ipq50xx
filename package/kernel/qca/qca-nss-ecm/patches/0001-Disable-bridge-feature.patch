From aa65b8a2c8d9ceac384f76209aa6905bcb65d664 Mon Sep 17 00:00:00 2001
From: hzy <hzyitc@outlook.com>
Date: Tue, 23 May 2023 21:10:02 +0000
Subject: [PATCH] Disable bridge feature

---
 frontends/nss/ecm_nss_ipv4.c | 227 ----------------------------------
 frontends/nss/ecm_nss_ipv6.c | 229 -----------------------------------
 2 files changed, 456 deletions(-)

diff --git a/frontends/nss/ecm_nss_ipv4.c b/frontends/nss/ecm_nss_ipv4.c
index 5e67aaa..259f48a 100644
--- a/frontends/nss/ecm_nss_ipv4.c
+++ b/frontends/nss/ecm_nss_ipv4.c
@@ -1691,222 +1691,6 @@ static unsigned int ecm_nss_ipv4_post_routing_hook(void *priv,
 	return result;
 }
 
-/*
- * ecm_front_end_ipv4_pppoe_bridge_process()
- *	Called for PPPoE session packets that are going
- *	out to one of the bridge physical interfaces.
- */
-static unsigned int ecm_front_end_ipv4_pppoe_bridge_process(struct net_device *out,
-						     struct net_device *in,
-						     struct ethhdr *skb_eth_hdr,
-						     bool can_accel,
-						     struct sk_buff *skb)
-{
-	struct ecm_tracker_ip_header ip_hdr;
-	unsigned int result = NF_ACCEPT;
-	struct pppoe_hdr *ph = pppoe_hdr(skb);
-	uint16_t ppp_proto = *(uint16_t *)ph->tag;
-	uint32_t encap_header_len = 0;
-
-	ppp_proto = ntohs(ppp_proto);
-	if (ppp_proto != PPP_IP) {
-		return NF_ACCEPT;
-	}
-
-	encap_header_len = ecm_front_end_l2_encap_header_len(ntohs(skb->protocol));
-	ecm_front_end_pull_l2_encap_header(skb, encap_header_len);
-	skb->protocol = htons(ETH_P_IP);
-
-	if (!ecm_tracker_ip_check_header_and_read(&ip_hdr, skb)) {
-		DEBUG_WARN("Invalid ip header in skb %px\n", skb);
-		goto skip_ipv4_process;
-	}
-
-	/*
-	 * Return if destination IP address is multicast address.
-	 */
-	if (ecm_ip_addr_is_multicast(ip_hdr.dest_addr)) {
-		DEBUG_WARN("Multicast acceleration is not support in PPPoE bridge %px\n", skb);
-		goto skip_ipv4_process;
-	}
-
-	result = ecm_nss_ipv4_ip_process(out, in, skb_eth_hdr->h_source,
-					 skb_eth_hdr->h_dest, can_accel,
-					 false, true, skb, ETH_P_PPP_SES);
-skip_ipv4_process:
-	ecm_front_end_push_l2_encap_header(skb, encap_header_len);
-	skb->protocol = htons(ETH_P_PPP_SES);
-
-	return result;
-}
-
-/*
- * ecm_nss_ipv4_bridge_post_routing_hook()
- *	Called for packets that are going out to one of the bridge physical interfaces.
- *
- * These may have come from another bridged interface or from a non-bridged interface.
- * Conntrack information may be available or not if this skb is bridged.
- */
-static unsigned int ecm_nss_ipv4_bridge_post_routing_hook(void *priv,
-					struct sk_buff *skb,
-					const struct nf_hook_state *nhs)
-{
-	struct net_device *out = nhs->out;
-	struct ethhdr *skb_eth_hdr;
-	uint16_t eth_type;
-	struct net_device *bridge;
-	struct net_device *in;
-	bool can_accel = true;
-	unsigned int result = NF_ACCEPT;
-
-	DEBUG_TRACE("%px: Bridge: %s\n", out, out->name);
-
-	/*
-	 * If operations have stopped then do not process packets
-	 */
-	spin_lock_bh(&ecm_nss_ipv4_lock);
-	if (unlikely(ecm_front_end_ipv4_stopped)) {
-		spin_unlock_bh(&ecm_nss_ipv4_lock);
-		DEBUG_TRACE("Front end stopped\n");
-		return NF_ACCEPT;
-	}
-	spin_unlock_bh(&ecm_nss_ipv4_lock);
-
-	/*
-	 * Don't process broadcast or multicast
-	 */
-	if (skb->pkt_type == PACKET_BROADCAST) {
-		DEBUG_TRACE("Broadcast, ignoring: %px\n", skb);
-		return NF_ACCEPT;
-	}
-
-	/*
-	 * skip l2tp/pptp because we don't accelerate them
-	 */
-	if (ecm_interface_is_l2tp_pptp(skb, out)) {
-		return NF_ACCEPT;
-	}
-
-	/*
-	 * Check packet is an IP Ethernet packet
-	 */
-	skb_eth_hdr = eth_hdr(skb);
-	if (!skb_eth_hdr) {
-		DEBUG_TRACE("%px: Not Eth\n", skb);
-		return NF_ACCEPT;
-	}
-	eth_type = ntohs(skb_eth_hdr->h_proto);
-	if (unlikely((eth_type != 0x0800) && (eth_type != ETH_P_PPP_SES))) {
-		DEBUG_TRACE("%px: Not IP/PPPoE session: %d\n", skb, eth_type);
-		return NF_ACCEPT;
-	}
-
-	/*
-	 * Identify interface from where this packet came.
-	 * There are three scenarios to consider here:
-	 * 1. Packet came from a local source.
-	 *	Ignore - local is not handled.
-	 * 2. Packet came from a routed path.
-	 *	Ignore - it was handled in INET post routing.
-	 * 3. Packet is bridged from another port.
-	 *	Process.
-	 *
-	 * Begin by identifying case 1.
-	 * NOTE: We are given 'out' (which we implicitly know is a bridge port) so out interface's master is the 'bridge'.
-	 */
-	bridge = ecm_interface_get_and_hold_dev_master((struct net_device *)out);
-	DEBUG_ASSERT(bridge, "Expected bridge\n");
-	in = dev_get_by_index(&init_net, skb->skb_iif);
-	if  (!in) {
-		/*
-		 * Case 1.
-		 */
-		DEBUG_TRACE("Local traffic: %px, ignoring traffic to bridge: %px (%s) \n", skb, bridge, bridge->name);
-		dev_put(bridge);
-		return NF_ACCEPT;
-	}
-	dev_put(in);
-
-	/*
-	 * Case 2:
-	 *	For routed packets the skb will have the src mac matching the bridge mac.
-	 * Case 3:
-	 *	If the packet was not local (case 1) or routed (case 2) then
-	 *	we process. There is an exception to case 2: when hairpin mode
-	 *	is enabled, we process.
-	 */
-
-	/*
-	 * Pass in NULL (for skb) and 0 for cookie since doing FDB lookup only
-	 */
-	in = br_port_dev_get(bridge, skb_eth_hdr->h_source, NULL, 0);
-	if (!in) {
-		DEBUG_TRACE("skb: %px, no in device for bridge: %px (%s)\n", skb, bridge, bridge->name);
-		dev_put(bridge);
-		return NF_ACCEPT;
-	}
-
-	/*
-	 * This flag needs to be checked in slave port(eth0/ath0)
-	 * and not on master interface(br-lan). Hairpin flag can be
-	 * enabled/disabled for ports individually.
-	 */
-	if (in == out) {
-		if (!br_is_hairpin_enabled(in)) {
-			DEBUG_TRACE("skb: %px, bridge: %px (%s), ignoring"
-					"the packet, hairpin not enabled"
-					"on port %px (%s)\n", skb, bridge,
-					bridge->name, out, out->name);
-			goto skip_ipv4_bridge_flow;
-		}
-		DEBUG_TRACE("skb: %px, bridge: %px (%s), hairpin enabled on port"
-				"%px (%s)\n", skb, bridge, bridge->name, out, out->name);
-	}
-
-	/*
-	 * Case 2: Routed trafffic would be handled by the INET post routing.
-	 */
-	if (!ecm_mac_addr_equal(skb_eth_hdr->h_source, bridge->dev_addr)) {
-		DEBUG_TRACE("skb: %px, Ignoring routed packet to bridge: %px (%s)\n", skb, bridge, bridge->name);
-		goto skip_ipv4_bridge_flow;
-	}
-
-	if (!is_multicast_ether_addr(skb_eth_hdr->h_dest)) {
-		/*
-		 * Process the packet, if we have this mac address in the fdb table.
-		 * TODO: For the kernel versions later than 3.6.x, the API needs vlan id.
-		 * 	 For now, we are passing 0, but this needs to be handled later.
-		 */
-		if (!br_fdb_has_entry((struct net_device *)out, skb_eth_hdr->h_dest, 0)) {
-			DEBUG_WARN("skb: %px, No fdb entry for this mac address %pM in the bridge: %px (%s)\n",
-					skb, skb_eth_hdr->h_dest, bridge, bridge->name);
-			goto skip_ipv4_bridge_flow;
-		}
-	}
-	DEBUG_TRACE("Bridge process skb: %px, bridge: %px (%s), In: %px (%s), Out: %px (%s)\n",
-			skb, bridge, bridge->name, in, in->name, out, out->name);
-
-	if (unlikely(eth_type != 0x0800)) {
-		/*
-		 * Check if PPPoE bridge acceleration is disabled.
-		 */
-		if (nss_pppoe_get_br_accel_mode() == NSS_PPPOE_BR_ACCEL_MODE_DIS) {
-			DEBUG_TRACE("skb: %px, PPPoE bridge flow acceleration is disabled\n", skb);
-			goto skip_ipv4_bridge_flow;
-		}
-
-		result = ecm_front_end_ipv4_pppoe_bridge_process((struct net_device *)out, in, skb_eth_hdr, can_accel, skb);
-		goto skip_ipv4_bridge_flow;
-	}
-
-	result = ecm_nss_ipv4_ip_process((struct net_device *)out, in,
-				skb_eth_hdr->h_source, skb_eth_hdr->h_dest, can_accel, false, false, skb, 0);
-skip_ipv4_bridge_flow:
-	dev_put(in);
-	dev_put(bridge);
-	return result;
-}
-
 #ifdef ECM_INTERFACE_OVS_BRIDGE_ENABLE
 /*
  * ecm_nss_ipv4_ovs_dp_process()
@@ -2543,17 +2327,6 @@ static struct nf_hook_ops ecm_nss_ipv4_netfilter_hooks[] __read_mostly = {
 		.hooknum        = NF_INET_POST_ROUTING,
 		.priority       = NF_IP_PRI_NAT_SRC + 1,
 	},
-
-	/*
-	 * The bridge post routing hook monitors packets going to interfaces that are part of a bridge arrangement.
-	 * For example Wireles LAN (WLAN) and Wired LAN (LAN).
-	 */
-	{
-		.hook		= ecm_nss_ipv4_bridge_post_routing_hook,
-		.pf		= PF_BRIDGE,
-		.hooknum	= NF_BR_POST_ROUTING,
-		.priority	= NF_BR_PRI_FILTER_OTHER,
-	},
 };
 
 /*
diff --git a/frontends/nss/ecm_nss_ipv6.c b/frontends/nss/ecm_nss_ipv6.c
index 685b108..259bb14 100644
--- a/frontends/nss/ecm_nss_ipv6.c
+++ b/frontends/nss/ecm_nss_ipv6.c
@@ -1458,224 +1458,6 @@ static unsigned int ecm_nss_ipv6_post_routing_hook(void *priv,
 	return result;
 }
 
-/*
- * ecm_nss_ipv6_pppoe_bridge_process()
- *	Called for PPPoE session packets that are going
- *	out to one of the bridge physical interfaces.
- */
-static unsigned int ecm_nss_ipv6_pppoe_bridge_process(struct net_device *out,
-						     struct net_device *in,
-						     struct ethhdr *skb_eth_hdr,
-						     bool can_accel,
-						     struct sk_buff *skb)
-{
-	struct ecm_tracker_ip_header ip_hdr;
-	unsigned int result = NF_ACCEPT;
-	struct pppoe_hdr *ph = pppoe_hdr(skb);
-	uint16_t ppp_proto = *(uint16_t *)ph->tag;
-	uint32_t encap_header_len = 0;
-
-	ppp_proto = ntohs(ppp_proto);
-	if (ppp_proto != PPP_IPV6) {
-		return NF_ACCEPT;
-	}
-
-	encap_header_len = ecm_front_end_l2_encap_header_len(ntohs(skb->protocol));
-	ecm_front_end_pull_l2_encap_header(skb, encap_header_len);
-	skb->protocol = htons(ETH_P_IPV6);
-
-	if (!ecm_tracker_ip_check_header_and_read(&ip_hdr, skb)) {
-		DEBUG_WARN("Invalid ip header in skb %px\n", skb);
-		goto skip_ipv6_process;
-	}
-
-	/*
-	 * Return if destination IP address is multicast address.
-	 */
-	if (ecm_ip_addr_is_multicast(ip_hdr.dest_addr)) {
-		DEBUG_WARN("Multicast acceleration is not support in PPPoE bridge %px\n", skb);
-		goto skip_ipv6_process;
-	}
-
-	result = ecm_nss_ipv6_ip_process(out, in, skb_eth_hdr->h_source,
-					 skb_eth_hdr->h_dest, can_accel,
-					 false, true, skb, ETH_P_PPP_SES);
-skip_ipv6_process:
-	ecm_front_end_push_l2_encap_header(skb, encap_header_len);
-	skb->protocol = htons(ETH_P_PPP_SES);
-
-	return result;
-}
-
-/*
- * ecm_nss_ipv6_bridge_post_routing_hook()
- *	Called for packets that are going out to one of the bridge physical interfaces.
- *
- * These may have come from another bridged interface or from a non-bridged interface.
- * Conntrack information may be available or not if this skb is bridged.
- */
-static unsigned int ecm_nss_ipv6_bridge_post_routing_hook(void *priv,
-					struct sk_buff *skb,
-					const struct nf_hook_state *nhs)
-{
-	struct net_device *out = nhs->out;
-	struct ethhdr *skb_eth_hdr;
-	uint16_t eth_type;
-	struct net_device *bridge;
-	struct net_device *in;
-	bool can_accel = true;
-	unsigned int result = NF_ACCEPT;
-
-	DEBUG_TRACE("%px: Bridge: %s\n", out, out->name);
-
-	/*
-	 * If operations have stopped then do not process packets
-	 */
-	spin_lock_bh(&ecm_nss_ipv6_lock);
-	if (unlikely(ecm_front_end_ipv6_stopped)) {
-		spin_unlock_bh(&ecm_nss_ipv6_lock);
-		DEBUG_TRACE("Front end stopped\n");
-		return NF_ACCEPT;
-	}
-	spin_unlock_bh(&ecm_nss_ipv6_lock);
-
-	/*
-	 * Don't process broadcast or multicast
-	 */
-	if (skb->pkt_type == PACKET_BROADCAST) {
-		DEBUG_TRACE("Broadcast, ignoring: %px\n", skb);
-		return NF_ACCEPT;
-	}
-
-	/*
-	 * skip l2tp/pptp because we don't accelerate them
-	 */
-	if (ecm_interface_is_l2tp_pptp(skb, out)) {
-		return NF_ACCEPT;
-	}
-
-	/*
-	 * Check packet is an IP Ethernet packet
-	 */
-	skb_eth_hdr = eth_hdr(skb);
-	if (!skb_eth_hdr) {
-		DEBUG_TRACE("%px: Not Eth\n", skb);
-		return NF_ACCEPT;
-	}
-	eth_type = ntohs(skb_eth_hdr->h_proto);
-	if (unlikely((eth_type != 0x86DD) && (eth_type != ETH_P_PPP_SES))) {
-		DEBUG_TRACE("%px: Not IP/PPPoE session\n", skb);
-		return NF_ACCEPT;
-	}
-
-	/*
-	 * Identify interface from where this packet came.
-	 * There are three scenarios to consider here:
-	 * 1. Packet came from a local source.
-	 *	Ignore - local is not handled.
-	 * 2. Packet came from a routed path.
-	 *	Ignore - it was handled in INET post routing.
-	 * 3. Packet is bridged from another port.
-	 *	Process.
-	 *
-	 * Begin by identifying case 1.
-	 * NOTE: We are given 'out' (which we implicitly know is a bridge port) so out interface's master is the 'bridge'.
-	 */
-	bridge = ecm_interface_get_and_hold_dev_master((struct net_device *)out);
-	DEBUG_ASSERT(bridge, "Expected bridge\n");
-	in = dev_get_by_index(&init_net, skb->skb_iif);
-	if (!in) {
-		/*
-		 * Case 1.
-		 */
-		DEBUG_TRACE("Local traffic: %px, ignoring traffic to bridge: %px (%s) \n", skb, bridge, bridge->name);
-		dev_put(bridge);
-		return NF_ACCEPT;
-	}
-	dev_put(in);
-
-	/*
-	 * Case 2:
-	 *	For routed packets the skb will have the src mac matching the bridge mac.
-	 * Case 3:
-	 *	If the packet was not local (case 1) or routed (case 2) then
-	 *	we process. There is an exception to case 2: when hairpin mode
-	 *	is enabled, we process.
-	 */
-
-	/*
-	 * Pass in NULL (for skb) and 0 for cookie since doing FDB lookup only
-	 */
-	in = br_port_dev_get(bridge, skb_eth_hdr->h_source, NULL, 0);
-	if (!in) {
-		DEBUG_TRACE("skb: %px, no in device for bridge: %px (%s)\n", skb, bridge, bridge->name);
-		dev_put(bridge);
-		return NF_ACCEPT;
-	}
-
-	/*
-	 * This flag needs to be checked in slave port(eth0/ath0)
-	 * and not on master interface(br-lan). Hairpin flag can be
-	 * enabled/disabled for ports individually.
-	 */
-	if (in == out) {
-		if (!br_is_hairpin_enabled(in)) {
-			DEBUG_TRACE("skb: %px, bridge: %px (%s), ignoring"
-					"the packet, hairpin not enabled"
-					"on port %px (%s)\n", skb, bridge,
-					bridge->name, out, out->name);
-			goto skip_ipv6_bridge_flow;
-		}
-		DEBUG_TRACE("skb: %px, bridge: %px (%s), hairpin enabled on port"
-				"%px (%s)\n", skb, bridge, bridge->name, out, out->name);
-	}
-
-	/*
-	 * Case 2: Routed trafffic would be handled by the INET post routing.
-	 */
-	if (!ecm_mac_addr_equal(skb_eth_hdr->h_source, bridge->dev_addr)) {
-		DEBUG_TRACE("skb: %px, Ignoring routed packet to bridge: %px (%s)\n", skb, bridge, bridge->name);
-		goto skip_ipv6_bridge_flow;
-	}
-
-	if (!is_multicast_ether_addr(skb_eth_hdr->h_dest)) {
-		/*
-		 * Process the packet, if we have this mac address in the fdb table.
-		 * TODO: For the kernel versions later than 3.6.x, the API needs vlan id.
-		 * 	 For now, we are passing 0, but this needs to be handled later.
-		 */
-		if (!br_fdb_has_entry((struct net_device *)out, skb_eth_hdr->h_dest, 0)) {
-			DEBUG_WARN("skb: %px, No fdb entry for this mac address %pM in the bridge: %px (%s)\n",
-					skb, skb_eth_hdr->h_dest, bridge, bridge->name);
-			goto skip_ipv6_bridge_flow;
-		}
-	}
-
-	DEBUG_TRACE("Bridge process skb: %px, bridge: %px (%s), In: %px (%s), Out: %px (%s)\n",
-			skb, bridge, bridge->name, in, in->name, out, out->name);
-
-	if (unlikely(eth_type != 0x86DD)) {
-		/*
-		 * Check if PPPoE bridge acceleration is disabled.
-		 */
-		if (nss_pppoe_get_br_accel_mode() == NSS_PPPOE_BR_ACCEL_MODE_DIS) {
-			DEBUG_TRACE("skb: %px, PPPoE bridge flow acceleration is disabled\n", skb);
-			goto skip_ipv6_bridge_flow;
-		}
-
-		result = ecm_nss_ipv6_pppoe_bridge_process((struct net_device *)out, in, skb_eth_hdr, can_accel, skb);
-		goto skip_ipv6_bridge_flow;
-	}
-
-	result = ecm_nss_ipv6_ip_process((struct net_device *)out, in,
-							skb_eth_hdr->h_source, skb_eth_hdr->h_dest, can_accel, false, false, skb, 0);
-skip_ipv6_bridge_flow:
-
-	dev_put(in);
-	dev_put(bridge);
-	return result;
-}
-
 #ifdef ECM_INTERFACE_OVS_BRIDGE_ENABLE
 /*
  * ecm_nss_ipv6_ovs_dp_process()
@@ -2282,17 +2064,6 @@ static struct nf_hook_ops ecm_nss_ipv6_netfilter_hooks[] __read_mostly = {
 		.hooknum        = NF_INET_POST_ROUTING,
 		.priority       = NF_IP6_PRI_NAT_SRC + 1,
 	},
-
-	/*
-	 * The bridge post routing hook monitors packets going to interfaces that are part of a bridge arrangement.
-	 * For example Wireles LAN (WLAN) and Wired LAN (LAN).
-	 */
-	{
-		.hook		= ecm_nss_ipv6_bridge_post_routing_hook,
-		.pf		= PF_BRIDGE,
-		.hooknum	= NF_BR_POST_ROUTING,
-		.priority	= NF_BR_PRI_FILTER_OTHER,
-	},
 };
 
 /*
-- 
2.25.1

